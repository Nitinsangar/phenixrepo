--[[
	Chat Parser and functions
]]

bartender.chat = {}
dofile ("chat/lisa.lua")
dofile ("chat/tradeParser.lua")
dofile ("data/personalities.lua")
dofile ("data/vocabulary.lua")
dofile ("chat/syntax.lua")
dofile ("chat/generator.lua")

local function printtable (t, offset)
	offset = offset or ""
	for k,v in pairs (t) do
		if type (v) == "table" then
			print (string.format ("%s%s", offset, tostring (k)))
			printtable (v, offset .. "-  ")
		else
			print (string.format ("%s%s = %s", offset, tostring (k), tostring (v)))
		end
	end
end

function bartender.chat:CreateParser (playerName)
	math.randomseed (os.time ())
	math.random (1, 100)
	
	local parser = {
		player = playerName,
		personality = bartender.data.people [math.random (1, #bartender.data.people)],
		syntax = bartender.chat:CreateSyntaxParser (),
		grammar = {},
		isDone = false,
		lastActive = os.time (),
		context = nil,
		tree = {},
		request = nil
	}
	
	function parser:SearchTree (tree, words)
		-- Loop through vocabulary and find possible response
		local results = {
			{
				hits = 0,
				score = 0,
				response = bartender.chat.ElizaParser
			}
		}
		local r, test, w, hits
		if words and #words > 0 then
			for _, r in ipairs (tree) do
				bartender:Yield ()
				hits = 0
				test = "|" .. table.concat (r.keywords, "|") .. "|"
				for _, w in ipairs (words) do
					if string.find (test, "|" .. w .. "|") then
						hits = hits + 1
					end
				end
				if hits > 0 then
					table.insert (results, {hits=hits, score=100 * hits/#r.keywords, response=r.response})
				end
			end
		end
		
		if #results > 1 then
			-- Sort all results by score then hits
			table.sort (results, function (a,b)
				if a.score > b.score or a.hits > b.hits then return true
				else return false
				end
			end)
		end
		
		return results [1].response
	end
	
	-- Builds response based on statistical hits on vocabulary definitions
	-- Returns either a string (actual response), table (parser object), or nil (handled internally and nothing else happens)
	local function GetResponse (grammar)
		local words = grammar.words
		local r = {}
		parser.tree = bartender.data.trunk
		
		-- Handle Basic Responses
		if #words == 1 and words [1] == "help" then
			bartender:ChatHelp (parser.player)
			return nil
			
		-- Handle Tree Driven Responses
		else
			if math.random (1, 50) > 50 then
				parser:SendMessage ("Hmmm...")
			end
			while (type (r) == "table") do
				r = parser:SearchTree (parser.tree, words)
				if type (r) == "table" then
					parser.tree = r
				end
				bartender:Yield ()
			end
		end
		
		-- Return type of response (either response string or parser)
		if type (r) == "function" then
			-- Return the parser to be generated by the function
			return r (parser)
		else
			-- Return the response string
			return r
		end
	end
	
	function parser:SendMessage (msg)
		local line
		for _, line in ipairs (messaging:Split (msg, "//")) do
			table.insert (messaging.queue, messaging:Message (parser.player, string.format ("(%s) %s", playerName, line), "STATION"))
		end
	end
	
	function parser:SendPrivateMessage (msg)
		local line
		for _, line in ipairs (messaging:Split (msg, "//")) do
			table.insert (messaging.queue, messaging:Message (parser.player, line))
		end
	end
	
	-- Starts up the parser
	function parser:Start ()
		-- Used to connect to an external database as needed
		if bartender.data.users [playerName] then
			parser:SendMessage (string.format ("Welcome back %s!", playerName))
		else
			parser:SendMessage ("Welcome!  What can I do for you?")
			bartender.data.users [playerName] = {
				debt = 0,
				reputation = 0
			}
		end
	end
	
	-- Stops the parser
	function parser:Stop ()
		--parser:SendMessage ("Bye.  Come back later!")
	end
	
	-- Parses the inbound string request
	function parser:Parse (request)
		if request and request:len () > 0 then
			print ("Parse - start")
			print (request)
			local response, tree
			parser.lastActive = os.time ()
			
			-- Check for response
			parser.grammar = parser.syntax:GetGrammar (request)
			print ("Syntax")
			printtable (parser.grammar.words)
			
			-- Complete a response to the player's input
			repeat
				if parser.context then
					print ("Context")
					response = parser.context:GetResponse (parser.grammar)
					if parser.context.isDone then
						parser.context = nil
					end
				else
					print ("Getting Tree Response")
					response = GetResponse (parser.grammar)
				end
				if response and response.isParser then
					parser.context = response
				end
			until type (response) == "string" or type (response) == "nil"
			if response then
				parser:SendMessage (response)
			end
			print ("Parse - end")
		end
	end
	
	return parser
end
